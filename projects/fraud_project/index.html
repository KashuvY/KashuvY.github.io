<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Federated Fraud Detection | Youval Kashuv </title> <meta name="author" content="Youval Kashuv"> <meta name="description" content="Privacy preserving fraud detection using TGNNs in a HFL environment"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%8C%83&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://kashuvy.github.io/projects/fraud_project/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Youval</span> Kashuv </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item active"> <a class="nav-link" href="/projects/">projects <span class="sr-only">(current)</span> </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Federated Fraud Detection</h1> <p class="post-description">Privacy preserving fraud detection using TGNNs in a HFL environment</p> </header> <article> <p>Credit card fraud is a persistent challenge for financial institutions, requiring sophisticated detection methods capable of analyzing large volumes of transactional data in real-time. Traditional machine learning models often struggle to capture the complex temporal and relational patterns present in transaction networks. Temporal Graph Neural Networks (TGNNs) have emerged as powerful tools for modeling such data, effectively integrating temporal dynamics with the structural relationships between entities.</p> <p>However, deploying TGNNs on sensitive financial data raises significant privacy concerns. Horizontal Federated Learning (HFL) offers a solution by enabling multiple institutions to collaboratively train a shared model without exchanging raw data. In this post, we delve into the mathematical foundations of integrating TGNNs within an HFL framework to enhance credit card fraud detection while preserving data privacy.</p> <p><strong>Project overview:</strong></p> <ul> <li>Implemented and trained a dynamic graph neural network (DGNN) in a <strong>horizontal federated learning</strong> (HFL) setting for anomalous and <strong>privacy preserving fraud detection</strong> of credit card transactions, <strong>successfully achieving \(&gt;96\%\) accuracy</strong> on datasets with upwards of 20 clients.</li> <li>Securely aggregated model weights from multiple banks without sharing customer data, reducing the risk of data breaches while maintaining model performance.</li> <li>Leveraged <strong>multi-GPU training</strong> for each participating bank and implemented efficient model aggregation, achieving a 20x speedup in overall training time and enabling near real-time fraud detection capabilities</li> </ul> <p><strong>Languages &amp; Libraries:</strong> python, PyTorch, NumPy, scikit-learn, pandas, matplotlib</p> <p><strong>Prerequisites:</strong> graph neural networks, deep learning</p> <hr> <h2 id="temporal-graph-neural-networks-tgnns">Temporal Graph Neural Networks (TGNNs)</h2> <h3 id="modeling-transaction-networks">Modeling Transaction Networks</h3> <p>Credit card transactions can be naturally represented as a temporal graph. Formally, let \(G = (V, E, T)\) denote a temporal graph where:</p> <ul> <li>\(V\) is the set of nodes representing credit card accounts.</li> <li>\(E \subset V \times V\) is the set of edges representing transactions between accounts.</li> <li>\(T\) is the set of timestamps associated with each edge. Each edge \(e=(u,v,t)\) carries features \(x_e\) (e.g., transaction amount, merchant category) and may have an associated label \(y_e\) indicating whether the transaction is fraudulent.</li> </ul> <h3 id="tgnn-architecture">TGNN Architecture</h3> <p>TGNNs extend traditional Graph Neural Networks by incorporating temporal information into the message-passing framework. The node embeddings \(h_v^t\) evolve over time based on interactions with neighboring nodes.</p> <p>The general update equations are:</p> <ol> <li> <p><strong>Message Function</strong>:</p> \[m_{u \rightarrow v}^{t} = \phi(h_u^{t^-}, h_v^{t^-}, x_{e}, t - t_{uv})\] <p>where:</p> <ul> <li>\(\phi\) is a learnable function.</li> <li>\(h_u^{t^-}\) is the embedding of node $u$ just before time \(t\).</li> <li>\(t_{uv}\) is the time of the last interaction between \(u\) and \(v\).</li> </ul> </li> <li> <p><strong>Aggregation Function</strong>:</p> \[m_v^{t} = \sum_{u \in \mathcal{N}_v^{t}} m_{u \rightarrow v}^{t}\] <p>where \(\mathcal{N}_v^{t}\) is the set of nodes interacting with \(v\) at time \(t\).</p> </li> <li> <p><strong>Update Function</strong>:</p> \[h_v^{t} = \psi(h_v^{t^-}, m_v^{t})\] <p>where \(\psi\) is another learnable function.</p> </li> </ol> <p>By iteratively applying these functions, the TGNN captures temporal dependencies and relational patterns crucial for identifying fraudulent activities.</p> <hr> <h2 id="horizontal-federated-learning-hfl">Horizontal Federated Learning (HFL)</h2> <h3 id="federated-learning-overview">Federated Learning Overview</h3> <p>Federated Learning enables multiple clients to collaboratively train a global model \(\theta\) without sharing their local data. Each client computes model updates using their data and sends these updates to a central server, which aggregates them to update the global model.</p> <h3 id="horizontal-federated-learning">Horizontal Federated Learning</h3> <p>In Horizontal Federated Learning, clients possess datasets with the same feature space but different samples. For credit card fraud detection, different banks or financial institutions act as clients, each holding transaction data for their customers.</p> <hr> <h2 id="integrating-tgnn-with-hfl">Integrating TGNN with HFL</h2> <h3 id="problem-formulation">Problem Formulation</h3> <p>Our objective is to train a global TGNN model \(\theta\) for fraud detection by leveraging decentralized transaction data across multiple institutions while ensuring data privacy.</p> <p>Each client \(k\) has its local transaction graph \(G_k = (V_k, E_k, T_k)\), with node features \(X_k\) and edge features \(E_k\).</p> <h3 id="local-training-objective">Local Training Objective</h3> <p>Each client minimizes a local loss function:</p> \[\mathcal{L}_k(\theta) = \frac{1}{|E_k|} \sum_{(e, y_e) \in E_k} \ell(f_\theta(e), y_e)\] <p>where:</p> <ul> <li>\(f_\theta(e)\) is the TGNNâ€™s prediction for edge \(e\).</li> <li>\(\ell\) is a loss function (e.g., cross-entropy loss).</li> </ul> <h3 id="federated-learning-process">Federated Learning Process</h3> <ol> <li> <p><strong>Initialization</strong>: The central server initializes the global model parameters $\theta_0$ and broadcasts them to all clients.</p> </li> <li> <p><strong>Local Training</strong>: Each client $k$ performs local training for $E$ epochs using its data $D_k$:</p> \[\theta_k = \theta_{t-1} - \eta \nabla \mathcal{L}_k(\theta_{t-1})\] <p>where \(\eta\) is the learning rate.</p> </li> <li> <p><strong>Model Upload</strong>: Clients send the updated parameters \(\theta_k\) to the server.</p> </li> <li> <p><strong>Aggregation</strong>: The server aggregates the client models to update the global model:</p> \[\theta_t = \sum_{k=1}^{K} \frac{n_k}{n} \theta_k\] <p>where:</p> <ul> <li>\(K\) is the number of clients.</li> <li> <table> <tbody> <tr> <td>$$n_k =</td> <td>D_k</td> <td>\(is the number of samples at client\)k$$.</td> </tr> </tbody> </table> </li> <li>\(n = \sum_{k=1}^{K} n_k\).</li> </ul> </li> <li> <p><strong>Iteration</strong>: Steps 2â€“4 are repeated for multiple rounds until convergence.</p> </li> </ol> <h2 id="mathematical-details">Mathematical Details</h2> <h3 id="message-passing-in-tgnn">Message Passing in TGNN</h3> <p>The message and update functions are instantiated as:</p> <ol> <li> <p><strong>Message Function</strong>: \(m_{u \rightarrow v}^{t} = \sigma\left(W_m [h_u^{t^-} \, \| \, h_v^{t^-} \, \| \, x_{e} \, \| \, \delta_t]\right)\)</p> <p>where:</p> <ul> <li>\(\sigma\) is an activation function (e.g., ReLU).</li> <li>\(W_m\) is a learnable weight matrix.</li> <li>\(\delta_t = t - t_{uv}\) is the time since the last interaction.</li> <li>\(\|\) denotes concatenation.</li> </ul> </li> <li> <p><strong>Update Function</strong>: \(h_v^{t} = \sigma\left(W_u [h_v^{t^-} \, \| \, m_v^{t}]\right)\)</p> <p>where \(W_u\) is another learnable weight matrix.</p> </li> </ol> <h3 id="loss-function">Loss Function</h3> <p>For binary fraud detection, the cross-entropy loss is:</p> \[\ell(f_\theta(e), y_e) = -\left[y_e \log f_\theta(e) + (1 - y_e) \log(1 - f_\theta(e))\right]\] <h3 id="federated-averaging">Federated Averaging</h3> <p>The aggregated global model parameters are computed as:</p> \[\theta_t = \sum_{k=1}^{K} \frac{n_k}{n} \theta_k\] <p>This weighted average ensures that clients with more data have a proportionally larger influence on the global model.</p> <h2 id="privacy-preservation">Privacy Preservation</h2> <h3 id="differential-privacy">Differential Privacy</h3> <p>To protect sensitive transaction data, clients can implement differential privacy by adding noise to their model updates:</p> <ol> <li> <p><strong>Gradient Clipping</strong>: \(\tilde{g}_k = \frac{g_k}{\max\left(1, \frac{\| g_k \|_2}{S} \right)}\)</p> <p>where \(S\) is the clipping threshold.</p> </li> <li> <p><strong>Noise Addition</strong>: \(\hat{g}_k = \tilde{g}_k + \mathcal{N}(0, \sigma^2 S^2 I)\)</p> <p>where:</p> <ul> <li>\(\mathcal{N}(0, \sigma^2 S^2 I)\) represents Gaussian noise with mean zero and covariance \(\sigma^2 S^2 I\).</li> <li>\(\sigma\) controls the noise scale.</li> </ul> </li> </ol> <p>This mechanism ensures that the influence of any single transaction on the model update is limited, providing formal privacy guarantees.</p> <h2 id="convergence-analysis">Convergence Analysis</h2> <h3 id="assumptions">Assumptions</h3> <ul> <li> <p><strong>Smoothness</strong>: Each local objective \(\mathcal{L}_k(\theta)\) is \(L\)-smooth: \(\|\nabla \mathcal{L}_k(\theta_1) - \nabla \mathcal{L}_k(\theta_2)\| \leq L \|\theta_1 - \theta_2\|\)</p> </li> <li> <p><strong>Bounded Variance</strong>: The variance of the stochastic gradients is bounded: \(\mathbb{E}_{\xi \sim D_k} \left[ \|\nabla_\theta \ell(\theta; \xi) - \nabla \mathcal{L}_k(\theta)\|^2 \right] \leq \sigma_k^2\)</p> </li> <li> <p><strong>Unbiased Gradients</strong>: The local gradients are unbiased estimates of the true gradient: \(\mathbb{E}_{\xi \sim D_k} \left[ \nabla_\theta \ell(\theta; \xi) \right] = \nabla \mathcal{L}_k(\theta)\)</p> </li> </ul> <h3 id="convergence-rate">Convergence Rate</h3> <p>Under these assumptions, the convergence rate of federated averaging can be characterized as:</p> \[\mathbb{E}\left[\mathcal{L}(\theta_t) - \mathcal{L}(\theta^*)\right] \leq \frac{L}{2 t \eta} \left\| \theta_0 - \theta^* \right\|^2\] <p>where:</p> <ul> <li>\(\theta_t\) is the global model at round $t$.</li> <li>\(\theta^*\) is the optimal model parameters.</li> <li>\(\eta\) is the learning rate.</li> </ul> <p>Proper choice of \(\eta\) and sufficient communication rounds \(t\) ensure convergence to the optimal solution.</p> <h2 id="communication-efficiency">Communication Efficiency</h2> <h3 id="reducing-communication-overhead">Reducing Communication Overhead</h3> <p>Communication between clients and the server can be a bottleneck. Techniques to mitigate this include:</p> <ul> <li> <strong>Model Compression</strong>: Clients transmit compressed model updates using methods like sparsification or quantization.</li> <li> <strong>Periodic Communication</strong>: Clients perform multiple local updates before communicating with the server.</li> <li> <strong>Adaptive Communication</strong>: Adjusting the communication frequency based on model convergence metrics.</li> </ul> <p>Mathematically, if \(\theta_k^\tau\) represents the model after \(\tau\) local updates, clients send \(\theta_k^\tau - \theta_{t-1}\), reducing the amount of data transmitted.</p> <h2 id="experimental-setup">Experimental Setup</h2> <p>While actual experimental results are beyond this scope, a typical setup would involve:</p> <ul> <li> <p><strong>Dataset</strong>: Real or simulated credit card transaction data partitioned across multiple institutions.</p> </li> <li> <strong>Baselines</strong>: <ul> <li>Centralized TGNN model trained on aggregated data (serves as an upper bound).</li> <li>Local TGNN models trained independently by each client.</li> <li>Federated models without temporal or graph components.</li> </ul> </li> <li> <strong>Metrics</strong>: <ul> <li> <strong>Detection Performance</strong>: Precision, recall, F1-score, area under the ROC curve.</li> <li> <strong>Communication Efficiency</strong>: Total data transmitted, number of communication rounds.</li> <li> <strong>Privacy Metrics</strong>: Differential privacy parameters (e.g., privacy budget $\varepsilon$).</li> </ul> </li> </ul> <h3 id="expected-outcomes">Expected Outcomes</h3> <ul> <li>The federated TGNN should achieve performance close to the centralized model while preserving data privacy.</li> <li>Communication-efficient techniques should reduce overhead without significantly impacting model accuracy.</li> <li>Differential privacy mechanisms should provide strong privacy guarantees with minimal loss in detection performance.</li> </ul> <h2 id="conclusion">Conclusion</h2> <p>Integrating Temporal Graph Neural Networks within a Horizontal Federated Learning framework provides a mathematically robust and practical approach to credit card fraud detection. This methodology effectively captures the intricate temporal and relational patterns in transaction data while ensuring that sensitive information remains secure.</p> <p>By enabling collaborative model training across institutions without sharing raw data, financial entities can enhance their fraud detection capabilities collectively. The mathematical formulations and privacy-preserving techniques discussed lay a solid foundation for implementing and advancing these models in real-world applications.</p> <h2 id="future-work">Future Work</h2> <ul> <li> <strong>Advanced Temporal Modeling</strong>: Incorporate attention mechanisms or sequence modeling techniques to better capture long-term dependencies.</li> <li> <strong>Personalized Federated Learning</strong>: Develop methods that allow clients to adapt the global model to their local data distributions.</li> <li> <strong>Enhanced Privacy Techniques</strong>: Explore cryptographic approaches like secure multi-party computation or homomorphic encryption to further strengthen privacy.</li> <li> <strong>Robustness to Heterogeneity</strong>: Address challenges arising from non-IID data distributions across clients, ensuring fair performance improvements.</li> </ul> <h2 id="final-remarks">Final Remarks</h2> <p>Mathematical rigor and privacy preservation are paramount when deploying machine learning models in sensitive domains like fraud detection. The fusion of TGNNs and Horizontal Federated Learning presents a promising avenue for both research and practical implementation, balancing performance with the critical need for data security.</p> </article> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> Â© Copyright 2024 Youval Kashuv. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> </body> </html>